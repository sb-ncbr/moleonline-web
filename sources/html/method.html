
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>MoleOnline | MOLE 2.0 and MOLEonline 2.0 Algorithm Explanation</title>
	<meta name="description" content="Method section describes the channel detection algorithm used in MOLE 2.0 and MOLEonline 2.0 using Voronoi diagram representation for the protein followed by spliting to smaller cavity diagrams and finding path between starting and ending points with Dijk">
	<meta name="author" content="Ing. Ondřej Hanák; http://ondrejhanak.cz">
	<link rel="shortcut icon" href="\images/favicon.ico" type="image/icon">
	<script type="text/javascript" src="\js/old-web/jsloader.js"></script>
	<link rel="stylesheet" type="text/css" media="screen" href="\css/old-web/cssloader.css">
		<link rel="stylesheet" href="\css/old-web/print.front.css" type="text/css" media="print">
		<link rel="stylesheet" href="\css/old-web/LiteMol-plugin.css" type="text/css">
		<link rel="stylesheet" href="\css/init-styles.css?version=1.4.6" type="text/css">


</head>

<body>

<div id="page">

	<div id="header">
		<h1><a href="/">MOLE<em>online</em></a></h1>
		<div id="topmenu">
			<ul>
				<li><a href="/">Home</a></li>
				<li><a href="/online">Online</a></li>
				<li class="active"><a href="/documentation">Documentation</a></li>
				<li><a href="/about">About</a></li>
			</ul>
		</div> <!-- #topmenu -->
	</div> <!-- #header -->

	<div id="content">
		

		<div id="submenu">
			<a class="active" href="/method">Method</a> | 
			<a href="/examples">Examples</a> | 
			<a href="/tour">Tour</a> | 
			<a href="/faq">FAQ</a>
		</div>

<h2>Tunnel search with MOLE 2.0 and MOLE<em>online</em> 2.0</h2>

<p>In short, a tunnel is a path between a point inside the macromolecular structure and its boundary. A tunnel is formed by its centerline and profile that specifies tunnel radius in each of centerline points. </p>

<p>In essence, to find a tunnel the <a href="http://old.mole.upol.cz/about/">previous version of MOLE</a> required the user to specify a starting point and from this point, the graph formed by the dual of the Delaunay triangulation (the Voronoi diagram, see bellow) got traversed in a depth first manner (paths with the lower cost were visited first). Each time a boundary vertex was reached, a tunnel got reported. </p>

<p>There are numerous problems with this approach. For example, when the first tunnel got reported, the next one was very similar to the first one (and therefore provided no useful additional information) because the path "branched" near the end point of the first tunnel. Another issue was caused by small "ridges" that were formed by vertices near the boundary of the diagram. As a result, a large part of the tunnel was often "going along" the surface of the protein and therefore they didn't provide a very relevant information about the structure of the tunnel. It was also very difficult to identify interesting starting points of the tunnels, unless prior knowledge.</p>

<p>The current version of the new <a href=http://mole.upol.cz/>MOLE 2.0</a> algorithm addresses these problems issues by preprocessing the Voronoi diagram, splitting it into several smaller parts (called <strong>cavity diagrams</strong>) and identifying suitable start and end points. Finally, Dijkstra's algorithm is used to find the tunnels. This algorithm is used also in MOLE<em>online</em> 2.0 web application.</p>
<img src="\images/alg_outline.jpg" alt="MOLE 2.0 Algorithm outline" align="right" width="550px">
<h2>MOLE 2.0 algorithm overview</h2>

<p>The tunnel computation in MOLE 2.0 is performed in several steps:</p>
<ul> 
<li>1. Calculate the Delaunay triangulation/Voronoi diagram of the atomic centers.</li> 
<li>2. Approximate the molecular surface by removing tetrahedrons that are too big. A tetrahedron is too big if a sphere with the <strong>Probe Radius</strong> can fit through it. Therefore, the smaller the Probe Radius is, the more tetrahedrons get removed.</li>
<li>3. Find cavities - remove tetrahedrons that are too small and identify connected components from the remaining tetrahedrons. A tetrahedron is too small if a sphere with the <strong>Interior Threshold</strong> radius <em>cannot</em> fit through it.</li>
<li>4. Identify the start point as the closest tetrahedron in a cavity that is within the <strong>Origin Radius</strong> distance from the selected residues. If there is no such tetrahedron, no tunnel can be found in the given cavity. This is done separately for each cavity.</li>
<li>5. Identify end points by covering boundary components of the cavities by a set of spheres with the <strong>Surface Cover Radius</strong> <em>r</em>. The distance between all pairs of end points is in the interval <<em>r</em>,2<em>r</em>>.</li>
<li>6. Compute the tunnels as shortest paths between all pairs of start and end points (that are in the same cavity). If two tunnels are too similar, the longer one is not reported.</li>
</ul>

<h3>1. Macromolecular Voronoi diagram representation</h3>
<img src="\images/voronoi_diagram.jpg" alt="Voronoi diagram" align="right" width="140px">
<p>The Voronoi diagram divides a metric space according to the distances between discrete sets of specified objects. In MOLE 2.0 case objects are the centres of the atom with van der Waals spheres. vdW radii of the spheres are taken from AMBER force field. The edges of the diagram represent equidistant positions between pairs of the closest atoms. The Voronoi diagram can be computed as a dual of the Delaunay triangulation of vdW sphere centers. Therefore, the vertices of the diagram correspond to the tetrahedrons of the triangulation and are located at the tetrahedrons' circumcenters. Similarly, the edges of the diagram represent the adjacency of the tetrahedrons.</p>


<h3>2. Preprocessing the diagram</h3>

<p>The preprocessing works in several steps:</p>
<ul>
<li>The boundary of the Voronoi diagram corresponds to the convex hull of the protein. This is not desirable because then the tunnel exits might end up being too far from the actual protein surface (similarly the shallow ridge issue of the previous algorithm). To remedy this, the user is required to specify the <strong>probe radius</strong> parameter which is used to approximate the molecular surface. Given this parameter, layers of vertices are removed repeatedly starting from the boundary layer if the probe would pass through corresponding tetrahedron.This process is repeated as long as there is no longer any vertex to remove.</li>
<li>The second step is the removal of vertices of the Voronoi diagram (i.e. tetrahedrons) that cannot be part of any tunnel. This is governed by a parameter called the <strong>interior threshold</strong>. This parameter serves as an approximate lower bound on the tunnel radius. A vertex is removed if a sphere with the interior threshold radius cannot pass through any of the tetrahedron's sides.</li>
<li>After the boundary and interior vertices are removed, the <strong>cavity diagrams</strong> are computed as the connected components of the Voronoi diagram. In essence, these cavity diagrams represent the empty space inside the macromolecule.</li>
<li>The last preprocessing step is to remove the shallow vertices. These are the vertices that form the above mentioned ridges along the surface of the molecule. All vertices with the distance (defined simply as a the number of the vertices on the path) from the surface less than a given internal threshold 5 are removed if all their neighbors have the same or lower depth.</li>
</ul>

<h3>3. Detection of Start points and End points</h3>
<p>Once the diagram is split into several smaller cavity diagrams, these are analyzed for suitable tunnel start points and end points between vertices of the cavity.
The general idea here is that the start point is the "deepest" vertex in the cavity and the end point is the "largest" boundary vertex (i.e. corresponding to the largest tetrahedron).</p>

<p><strong>Start Points</strong></p>
<p>There are two ways to specify a start point for a tunnel - user specified list of residues, XYZ coordinates or (MOLE 2.0 only) automatic computation:</p>
<ul>
<li><p> User defined: </p></li>
<p>The user specifies a list of residues or a 3D point. Next, the centroid calculated from all the corresponding atomic centers is computed. Finally, for each cavity within a specified <strong>origin radius</strong> the closest vertex is selected as a start point.</p>
<li><p>Calculated: (MOLE 2.0 only)</p></li>
<p>The topology of the cavity is used to calculate the start point. The calculated starting point is the "deepest" vertex of a cavity. The depth of a vertex is defined as the length of the path from this vertex to the closest boundary vertex.</p>
</ul>
<p><strong>End Points</strong></p>
<p>Similarly to the start points, endpoints are either user defined (MOLE 2.0 desktop version only) or calculated:</p>
<ul>
<li><p>User defined: </p></li>
<p>These end points can be specified by clicking on the surface of the molecule in MOLE 2.0 desktop aplication.</p>
<li><p>Calculated: </p></li>
<p>For each cavity diagram a subgraph B is induced by the boundary vertices. Then, the connected components of B are computed. Finally, each component is covered with spheres with the <strong>surface cover radius</strong> and the tetrahedrons corresponding to the centers of these spheres are marked as tunnel exits.</p>
</ul>

<h3>4. Tunnel computation</h3>
<p>Finally, when the set of start and end points is identified for each cavity, the Dijkstra's Shortest Path algorithm is used to find the tunnels between all pairs of start and end points points (or the molecular surface if the algorithm reaches it before it finds the tunnel exit). The edge weight function used in the algorithm takes into account the distance to the surface of the closest vdW sphere and the edge length.</p>
<p>Then the tunnel centerline is represented as a 3D natural spline representation defined by the Voronoi diagram vertices that form the path found by the Dijkstra's algorithm.</p>
<p>Because of the density of the computed exits, the algorithm might find duplicate tunnels. Therefore, in the last post-processing step, these duplicate tunnels are removed.</p>

<h3>Assignment of physico-chemical properties</h3>
<p>When tunnel is shown, a set of unique residues lining it is shown, while those surrounding the tunnel with side chain are noted. According to side chain, a list of properties is calculated (for lining aminoacid side chains only):</p>
<ul>
<li><strong>Charge</strong> is calculated as a sum of charged residues (Arg, Lys, His = +1; Asp, Glu = -1)
<li><strong>Hydropathy</strong> of the tunnel is calculated as an average of hydropathy index assigned to residues according to the method of Kyte and Doolitle. <a href="http://www.sciencedirect.com/science/article/pii/0022283682905150">(Kyte, J. and Doolittle, R.F., A simple method for displaying the hydropathic character of a protein, J. Mol. Biol. 157, 105-132 (1982)).</a> Hydropathy index is connected with hydrophilicity/hydrophobicity of amino acids (most hydrophilic Arg = -4.5, most hydrophobic Ile = 4.5). 
<li><strong>Hydrophobicity</strong> is calculated as an average of normalized hydrophobicity scales by Cid et al. <a href="http://peds.oxfordjournals.org/content/5/5/373.short">(Cid, H. et al. Hydrophobicity and structural classes in proteins, J Protein Engineering 5, 373-375 (1992))</a>. Most hydrophilic residue according to hydrophobicity value is Glu (-1.140) and the most hydrophobic is Ile (1.810).
<li><strong>Polarity</strong> is calculated as an average of amino acid polarities assigned according to the method of Zimmerman et al. <a href="http://www.sciencedirect.com/science/article/pii/0022519368900696">(Zimmerman, J.M. et al. The characterization of amino acid sequences in proteins by statistical methods, J. Theor. Biol. 21, 170-201 (1968))</a>. Polarity ranges from completely nonpolar aminoacids (Ala, Gly = 0.00) through polar residues (e.g. Ser = 1.67) towards charged residues (Glu = 49.90, Arg = 52.00). 
<li><strong>Mutability</strong> is calculated as an average of relative mutability index <a href="http://bioinformatics.oxfordjournals.org/content/8/3/275.short">(Jones, D.T., Taylor, W.T. and Thornton, J.M. The rapid generation of mutation data matrices from protein sequences, Comput Appl Biosci (1992) 8 (3): 275-282.)</a>. Relative mutability is based on empirical substitution matrices between similar protein sequences. It is high wherever aminoacid can be easily substituted for another e.g. in case of small polar amino acids (Ser = 117, Thr = 107, Asn = 104) or in case of small aliphatic amino acids (Ala = 100, Val = 98, Ile = 103). On the other hand it is low when amino acid plays important structural role such as in case of aromatic amino acids (Trp = 25, Phe = 51, Tyr = 50) or in case of special amino acids (Cys = 44, Pro = 58, Gly = 50). Specific example of amino acid with low relative mutability is the most abundant amino acid (Leu = 54) which has the highest probability to mutate back to itself.</li>
</ul>

<h3>Note on advanced options</h3>
<p>Advanced settings offers possibility to adjust parameters determining tunnel searching algorithm. All parameters are set in Angstroms (0.1 nm):</p>
<ul>
<li><strong>Probe radius</strong> - Radius used for construction of surface of biomacromolecule.</li> 
<li><strong>Interior threshold</strong> - Approximate smallest tunnel radius to use.</li>
<li><strong>Surface Cover Radius</strong> - Determines the density of tunnel exits on the molecular surface.</li>
<li><strong>Origin radius</strong> - Localization of starting point within this radius.</li>
<li><strong>Starting point [X,Y,Z]</strong> - Precise localization of starting point instead of list of residues.</li>
</ul>

<h3>Final Note on the complexity of the algorithm</h3>
<p>The worst case complexity of the algorithm is O(M log M) where M is the number of vertices of the Voronoi diagram. In the worst case, M = N<sup>2</sup>, where N is the number of atoms. However, in most practical cases M is almost equal to N. Additionally, the complexity of calculating the Voronoi diagram is O(N log N). The complexity of all steps of the pre-processing phase is at most O(M log M). Finding the paths using the Dijkstra's algorithm is O(K M logM) where K is number of tunnels. </p>
<p>Together, the complexity of the MOLE 2.0 tunnel search algorithm is O(K N<sup>2</sup> log N), where K is the number of detected tunnels and N is the number of atoms in the molecule.</p>	</div> <!-- #content -->
	<hr class="cleaner">

</div> <!-- #page -->

<div id="ajaxspinner"></div>
<!--<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4336835-6']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>-->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-4336835-7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-4336835-7');
</script>
</body>
</html>

